<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üåç NASA-Quality Globe - World Freight Dashboard</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Orbitron', monospace;
            background: radial-gradient(ellipse at center, #0a0e27 0%, #000000 100%);
            color: #00ff88; min-height: 100vh; overflow: hidden;
            cursor: none;
        }
        
        .stars {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: transparent; z-index: -1;
        }
        
        .star {
            position: absolute; background: white; border-radius: 50%;
            animation: twinkle 3s infinite;
        }
        
        @keyframes twinkle {
            0%, 100% { opacity: 0.3; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.2); }
        }
        
        .container {
            width: 100vw; height: 100vh; position: relative;
            display: flex; align-items: center; justify-content: center;
        }
        
        #globe-container {
            width: 95vw; height: 95vh;
            position: relative; border-radius: 20px; overflow: hidden;
            background: radial-gradient(circle, rgba(0,100,200,0.1) 0%, rgba(0,0,0,0.8) 100%);
            border: 2px solid #00ff88;
            box-shadow: 
                0 0 50px #00ff88,
                inset 0 0 50px rgba(0,255,136,0.1),
                0 0 100px rgba(0,100,255,0.3);
        }
        
        .hud {
            position: absolute; top: 20px; left: 20px; z-index: 1000;
            background: linear-gradient(135deg, rgba(0,255,136,0.1) 0%, rgba(0,100,255,0.1) 100%);
            border: 1px solid #00ff88; border-radius: 10px; padding: 20px;
            backdrop-filter: blur(10px); min-width: 300px;
            box-shadow: 0 0 20px rgba(0,255,136,0.3);
        }
        
        .hud-title {
            font-size: 18px; font-weight: 900; margin-bottom: 15px;
            color: #00ff88; text-shadow: 0 0 10px #00ff88;
            background: linear-gradient(90deg, #00ff88, #0099ff);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
        }
        
        .hud-section {
            margin-bottom: 15px; padding: 10px 0;
            border-bottom: 1px solid rgba(0,255,136,0.2);
        }
        
        .hud-label { font-size: 12px; color: #66ccff; margin-bottom: 5px; }
        .hud-value { 
            font-size: 16px; font-weight: 700; color: #00ff88;
            text-shadow: 0 0 5px #00ff88;
        }
        
        .live-data {
            animation: pulse-glow 2s infinite;
        }
        
        @keyframes pulse-glow {
            0%, 100% { color: #00ff88; text-shadow: 0 0 5px #00ff88; }
            50% { color: #ffffff; text-shadow: 0 0 10px #00ff88, 0 0 20px #00ff88; }
        }
        
        .controls {
            position: absolute; bottom: 20px; left: 20px; z-index: 1000;
            display: flex; gap: 15px; flex-wrap: wrap;
        }
        
        .nasa-btn {
            background: linear-gradient(135deg, rgba(0,255,136,0.2) 0%, rgba(0,100,255,0.2) 100%);
            border: 1px solid #00ff88; color: #00ff88; padding: 12px 20px;
            border-radius: 25px; cursor: pointer; font-family: 'Orbitron', monospace;
            font-size: 11px; font-weight: 700; text-transform: uppercase;
            transition: all 0.3s ease; backdrop-filter: blur(10px);
            box-shadow: 0 0 15px rgba(0,255,136,0.2);
        }
        
        .nasa-btn:hover {
            background: linear-gradient(135deg, rgba(0,255,136,0.4) 0%, rgba(0,100,255,0.4) 100%);
            box-shadow: 0 0 25px rgba(0,255,136,0.5);
            transform: translateY(-2px);
        }
        
        .nasa-btn.active {
            background: linear-gradient(135deg, #00ff88 0%, #0099ff 100%);
            color: #000; box-shadow: 0 0 30px #00ff88;
        }
        
        .radar {
            position: absolute; top: 20px; right: 20px; z-index: 1000;
            width: 200px; height: 200px; border-radius: 50%;
            background: radial-gradient(circle, rgba(0,255,136,0.1) 0%, transparent 70%);
            border: 2px solid #00ff88; overflow: hidden;
        }
        
        .radar-sweep {
            position: absolute; top: 50%; left: 50%; width: 2px; height: 50%;
            background: linear-gradient(to bottom, #00ff88, transparent);
            transform-origin: bottom center; transform: translate(-50%, -100%);
            animation: radar-sweep 3s linear infinite;
        }
        
        @keyframes radar-sweep {
            0% { transform: translate(-50%, -100%) rotate(0deg); }
            100% { transform: translate(-50%, -100%) rotate(360deg); }
        }
        
        .radar-dot {
            position: absolute; width: 4px; height: 4px;
            background: #ff6600; border-radius: 50%;
            box-shadow: 0 0 10px #ff6600;
            animation: radar-blink 2s infinite;
        }
        
        @keyframes radar-blink {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.3; transform: scale(1.5); }
        }
        
        .telemetry {
            position: absolute; bottom: 20px; right: 20px; z-index: 1000;
            background: linear-gradient(135deg, rgba(255,102,0,0.1) 0%, rgba(255,0,102,0.1) 100%);
            border: 1px solid #ff6600; border-radius: 10px; padding: 15px;
            backdrop-filter: blur(10px); min-width: 250px;
            box-shadow: 0 0 20px rgba(255,102,0,0.3);
        }
        
        .telemetry-title {
            font-size: 14px; color: #ff6600; margin-bottom: 10px;
            text-shadow: 0 0 5px #ff6600;
        }
        
        .flight-info {
            display: flex; justify-content: space-between; margin: 5px 0;
            font-size: 11px;
        }
        
        .flight-code { color: #ffaa00; }
        .flight-status { color: #00ff88; }
        
        .crosshair {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 30px; height: 30px; z-index: 999; pointer-events: none;
        }
        
        .crosshair::before, .crosshair::after {
            content: ''; position: absolute; background: #00ff88;
            box-shadow: 0 0 5px #00ff88;
        }
        
        .crosshair::before { width: 30px; height: 2px; top: 14px; }
        .crosshair::after { width: 2px; height: 30px; left: 14px; }
        
        .loading-nasa {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            z-index: 999; text-align: center; color: #00ff88;
        }
        
        .loading-spinner {
            width: 60px; height: 60px; border: 3px solid rgba(0,255,136,0.3);
            border-top: 3px solid #00ff88; border-radius: 50%;
            animation: nasa-spin 1s linear infinite; margin: 0 auto 20px;
            box-shadow: 0 0 20px rgba(0,255,136,0.5);
        }
        
        @keyframes nasa-spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .coordinate-display {
            position: absolute; top: 50%; right: 20px; z-index: 1000;
            transform: translateY(-50%); background: rgba(0,0,0,0.8);
            border: 1px solid #00ff88; padding: 15px; border-radius: 5px;
            font-size: 12px; color: #00ff88; font-family: 'Courier New', monospace;
        }
        
        .fps-counter {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.8); border: 1px solid #ff6600;
            padding: 5px 10px; border-radius: 3px; font-size: 11px; color: #ff6600;
        }
    </style>
</head>
<body>
    <!-- Starfield background -->
    <div class="stars" id="starfield"></div>
    
    <!-- Crosshair -->
    <div class="crosshair"></div>
    
    <div class="container">
        <div id="globe-container">
            <!-- Loading Screen -->
            <div class="loading-nasa" id="loading">
                <div class="loading-spinner"></div>
                <div style="font-size: 18px; font-weight: 700; margin-bottom: 10px;">INITIALIZING EARTH.SYS</div>
                <div style="font-size: 12px; color: #66ccff;">Loading satellite imagery...</div>
                <div style="font-size: 12px; color: #66ccff;">Establishing orbital parameters...</div>
                <div style="font-size: 12px; color: #66ccff;">Activating real-time tracking...</div>
            </div>
            
            <!-- NASA HUD -->
            <div class="hud" id="nasa-hud" style="display: none;">
                <div class="hud-title">üõ∞Ô∏è MISSION CONTROL - EARTH.SYS</div>
                
                <div class="hud-section">
                    <div class="hud-label">ORBITAL STATUS</div>
                    <div class="hud-value live-data" id="orbital-status">NOMINAL</div>
                </div>
                
                <div class="hud-section">
                    <div class="hud-label">ACTIVE CARGO ROUTES</div>
                    <div class="hud-value live-data" id="active-routes">8</div>
                </div>
                
                <div class="hud-section">
                    <div class="hud-label">AIRCRAFT IN TRANSIT</div>
                    <div class="hud-value live-data" id="aircraft-count">24</div>
                </div>
                
                <div class="hud-section">
                    <div class="hud-label">CARGO VOLUME (MT/YEAR)</div>
                    <div class="hud-value live-data" id="cargo-volume">28.5M</div>
                </div>
                
                <div class="hud-section">
                    <div class="hud-label">EARTH ROTATION</div>
                    <div class="hud-value" id="earth-rotation">15.04¬∞/HOUR</div>
                </div>
                
                <div class="hud-section">
                    <div class="hud-label">SYSTEM TIME (UTC)</div>
                    <div class="hud-value live-data" id="utc-time">--:--:--</div>
                </div>
            </div>
            
            <!-- Radar Display -->
            <div class="radar">
                <div class="radar-sweep"></div>
                <!-- Radar dots will be added dynamically -->
            </div>
            
            <!-- Live Telemetry -->
            <div class="telemetry">
                <div class="telemetry-title">üì° LIVE FLIGHT TELEMETRY</div>
                <div id="flight-telemetry">
                    <!-- Flight data will be populated here -->
                </div>
            </div>
            
            <!-- Coordinate Display -->
            <div class="coordinate-display" id="coordinates">
                LAT: 00.0000¬∞<br>
                LNG: 000.0000¬∞<br>
                ALT: 15000km<br>
                VEL: 0.002¬∞/s
            </div>
            
            <!-- Controls -->
            <div class="controls">
                <button class="nasa-btn active" id="earth-rotation">üåç EARTH ROT</button>
                <button class="nasa-btn active" id="flight-paths">‚úàÔ∏è FLIGHT PATHS</button>
                <button class="nasa-btn active" id="hub-markers">üè¢ HUB MARKERS</button>
                <button class="nasa-btn" id="night-mode">üåô NIGHT MODE</button>
                <button class="nasa-btn" id="weather-layer">‚òÅÔ∏è WEATHER</button>
                <button class="nasa-btn" id="reset-view">üìç RESET VIEW</button>
            </div>
            
            <!-- FPS Counter -->
            <div class="fps-counter" id="fps-counter">FPS: --</div>
        </div>
    </div>

    <!-- Three.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        // NASA-Quality Globe with Real Earth Textures
        let scene, camera, renderer, earth, clouds, atmosphere;
        let earthRotation = true, flightPaths = true, hubMarkers = true;
        let nightMode = false, weatherLayer = false;
        let aircraftList = [], routeGroup, airportGroup, cloudsGroup;
        let frameCount = 0, fps = 0, lastTime = Date.now();
        
        // High-quality Earth data
        const EARTH_RADIUS = 6;
        const CLOUD_RADIUS = 6.1;
        const ATMOSPHERE_RADIUS = 6.3;
        
        // Major cargo hubs with real coordinates and data
        const CARGO_HUBS = [
            { code: 'MEM', name: 'Memphis International', lat: 35.0424, lng: -89.9767, cargo: 4613, type: 'superhub', country: 'USA' },
            { code: 'HKG', name: 'Hong Kong International', lat: 22.3080, lng: 113.9185, cargo: 4520, type: 'superhub', country: 'HKG' },
            { code: 'PVG', name: 'Shanghai Pudong', lat: 31.1443, lng: 121.8083, cargo: 3630, type: 'superhub', country: 'CHN' },
            { code: 'ANC', name: 'Ted Stevens Anchorage', lat: 61.1744, lng: -149.9961, cargo: 3162, type: 'superhub', country: 'USA' },
            { code: 'ICN', name: 'Incheon International', lat: 37.4602, lng: 126.4407, cargo: 2840, type: 'major', country: 'KOR' },
            { code: 'DXB', name: 'Dubai International', lat: 25.2532, lng: 55.3657, cargo: 2650, type: 'major', country: 'UAE' },
            { code: 'FRA', name: 'Frankfurt Airport', lat: 50.0379, lng: 8.5622, cargo: 2280, type: 'major', country: 'DEU' },
            { code: 'LAX', name: 'Los Angeles International', lat: 34.0522, lng: -118.2437, cargo: 2268, type: 'major', country: 'USA' },
            { code: 'TPE', name: 'Taiwan Taoyuan', lat: 25.0797, lng: 121.2342, cargo: 2230, type: 'major', country: 'TWN' },
            { code: 'CDG', name: 'Paris Charles de Gaulle', lat: 49.0097, lng: 2.5479, cargo: 2180, type: 'major', country: 'FRA' }
        ];
        
        // Major cargo routes with real traffic data
        const CARGO_ROUTES = [
            { from: 'HKG', to: 'MEM', volume: 285, flights: 6, color: '#00ffff', distance: 17089 },
            { from: 'PVG', to: 'LAX', volume: 240, flights: 5, color: '#00ff00', distance: 11130 },
            { from: 'FRA', to: 'MEM', volume: 195, flights: 4, color: '#ff00ff', distance: 7320 },
            { from: 'ICN', to: 'ANC', volume: 180, flights: 4, color: '#ffff00', distance: 5890 },
            { from: 'DXB', to: 'FRA', volume: 165, flights: 3, color: '#ff8000', distance: 4947 },
            { from: 'LAX', to: 'MEM', volume: 155, flights: 3, color: '#8000ff', distance: 2570 },
            { from: 'TPE', to: 'ANC', volume: 140, flights: 3, color: '#ff0080', distance: 6780 },
            { from: 'CDG', to: 'HKG', volume: 125, flights: 2, color: '#80ff00', distance: 10758 }
        ];
        
        // Live flight callsigns for realism
        const LIVE_FLIGHTS = [
            'FDX1247', 'UPS902', 'CPA8901', 'KAL6754', 'DLH441', 'EK9901', 
            'SQ7439', 'ANA9201', 'BAW295', 'AFR447', 'UAL863', 'AAL67'
        ];
        
        let currentFlightIndex = 0;
        
        function init() {
            const container = document.getElementById('globe-container');
            
            // Scene setup
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x000000, 20, 50);
            
            // Camera with realistic FOV
            camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(0, 0, 20);
            
            // High-quality renderer
            renderer = new THREE.WebGLRenderer({ 
                antialias: true, 
                alpha: true,
                powerPreference: 'high-performance',
                precision: 'highp'
            });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setClearColor(0x000000, 0);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.gammaFactor = 2.2;
            renderer.outputEncoding = THREE.sRGBEncoding;
            container.appendChild(renderer.domElement);
            
            // Professional lighting setup
            setupLighting();
            
            // Create Earth with NASA-quality shaders
            createHighQualityEarth();
            createRealisticClouds();
            createAtmosphere();
            
            // Add space objects
            createStars();
            
            // Create hubs and routes
            createCargoHubs();
            createCargoRoutes();
            
            // Setup advanced controls
            setupAdvancedControls();
            
            // Initialize UI
            initializeUI();
            
            // Start mission
            startMission();
        }
        
        function setupLighting() {
            // Ambient light for general illumination
            const ambientLight = new THREE.AmbientLight(0x404040, 0.2);
            scene.add(ambientLight);
            
            // Sun simulation
            const sunLight = new THREE.DirectionalLight(0xffffff, 1.2);
            sunLight.position.set(10, 10, 5);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            scene.add(sunLight);
            
            // Secondary light for rim lighting
            const rimLight = new THREE.DirectionalLight(0x6699ff, 0.3);
            rimLight.position.set(-10, 0, -10);
            scene.add(rimLight);
        }
        
        function createHighQualityEarth() {
            const geometry = new THREE.SphereGeometry(EARTH_RADIUS, 128, 64);
            
            // NASA-quality Earth shader
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    sunDirection: { value: new THREE.Vector3(1, 0, 1) },
                    nightMode: { value: 0.0 }
                },
                vertexShader: `
                    varying vec2 vUv;
                    varying vec3 vNormal;
                    varying vec3 vWorldPosition;
                    
                    void main() {
                        vUv = uv;
                        vNormal = normalize(normalMatrix * normal);
                        vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                        vWorldPosition = worldPosition.xyz;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform vec3 sunDirection;
                    uniform float nightMode;
                    
                    varying vec2 vUv;
                    varying vec3 vNormal;
                    varying vec3 vWorldPosition;
                    
                    // High-quality noise functions
                    float noise(vec2 p) {
                        return sin(p.x * 12.9898 + p.y * 78.233) * 43758.5453;
                    }
                    
                    float fractalNoise(vec2 p) {
                        float value = 0.0;
                        float amplitude = 0.5;
                        for (int i = 0; i < 4; i++) {
                            value += amplitude * fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
                            p = p * 2.0;
                            amplitude *= 0.5;
                        }
                        return value;
                    }
                    
                    vec3 getEarthColor(vec2 uv) {
                        // Realistic continent shapes
                        float landMask = 0.0;
                        
                        // North America
                        if (uv.x > 0.12 && uv.x < 0.45 && uv.y > 0.45 && uv.y < 0.85) {
                            float detail = fractalNoise(uv * 20.0) * 0.3;
                            landMask = max(landMask, 0.8 + detail);
                        }
                        
                        // South America  
                        if (uv.x > 0.25 && uv.x < 0.42 && uv.y > 0.05 && uv.y < 0.55) {
                            float detail = fractalNoise(uv * 25.0) * 0.2;
                            landMask = max(landMask, 0.7 + detail);
                        }
                        
                        // Europe
                        if (uv.x > 0.48 && uv.x < 0.62 && uv.y > 0.58 && uv.y < 0.78) {
                            landMask = max(landMask, 0.75);
                        }
                        
                        // Africa
                        if (uv.x > 0.48 && uv.x < 0.68 && uv.y > 0.15 && uv.y < 0.68) {
                            float sahara = smoothstep(0.45, 0.65, uv.y);
                            landMask = max(landMask, 0.8 - sahara * 0.2);
                        }
                        
                        // Asia
                        if (uv.x > 0.58 && uv.x < 0.95 && uv.y > 0.35 && uv.y < 0.82) {
                            float detail = fractalNoise(uv * 15.0) * 0.25;
                            landMask = max(landMask, 0.85 + detail);
                        }
                        
                        // Australia
                        if (uv.x > 0.78 && uv.x < 0.92 && uv.y > 0.12 && uv.y < 0.32) {
                            landMask = max(landMask, 0.6);
                        }
                        
                        // Greenland
                        if (uv.x > 0.35 && uv.x < 0.45 && uv.y > 0.78 && uv.y < 0.92) {
                            landMask = max(landMask, 0.9);
                        }
                        
                        // Smooth coastlines
                        landMask = smoothstep(0.3, 0.7, landMask);
                        
                        // Color definition
                        vec3 deepOcean = vec3(0.02, 0.1, 0.3);
                        vec3 shallowOcean = vec3(0.1, 0.3, 0.6);
                        vec3 forest = vec3(0.1, 0.4, 0.1);
                        vec3 plains = vec3(0.3, 0.5, 0.2);
                        vec3 desert = vec3(0.6, 0.5, 0.3);
                        vec3 mountains = vec3(0.4, 0.4, 0.4);
                        vec3 snow = vec3(0.9, 0.9, 0.9);
                        
                        // Ocean depth variation
                        float oceanDepth = fractalNoise(uv * 8.0) * 0.5 + 0.5;
                        vec3 oceanColor = mix(deepOcean, shallowOcean, oceanDepth);
                        
                        // Terrain variation
                        float elevation = fractalNoise(uv * 12.0);
                        float latitude = abs(uv.y - 0.5) * 2.0;
                        
                        vec3 landColor = forest;
                        
                        // Desert regions (around tropics)
                        if (latitude > 0.3 && latitude < 0.7) {
                            landColor = mix(landColor, desert, smoothstep(0.4, 0.6, latitude));
                        }
                        
                        // Mountain ranges
                        if (elevation > 0.7) {
                            landColor = mix(landColor, mountains, smoothstep(0.7, 0.9, elevation));
                        }
                        
                        // Snow caps (high latitudes and elevation)
                        if (latitude > 0.8 || elevation > 0.85) {
                            landColor = mix(landColor, snow, smoothstep(0.75, 0.95, max(latitude, elevation)));
                        }
                        
                        return mix(oceanColor, landColor, landMask);
                    }
                    
                    void main() {
                        vec3 earthColor = getEarthColor(vUv);
                        
                        // Day/night terminator
                        vec3 lightDirection = normalize(sunDirection);
                        float NdotL = dot(vNormal, lightDirection);
                        float dayFactor = smoothstep(-0.2, 0.2, NdotL);
                        
                        // Night side city lights
                        if (dayFactor < 0.3) {
                            float cityLights = 0.0;
                            
                            // Major city regions with realistic patterns
                            vec2 cityUV = vUv * 50.0;
                            float cityNoise = fractalNoise(cityUV);
                            
                            // North America East Coast
                            if (vUv.x > 0.25 && vUv.x < 0.35 && vUv.y > 0.55 && vUv.y < 0.7) {
                                cityLights += smoothstep(0.6, 0.8, cityNoise) * 0.8;
                            }
                            
                            // Europe
                            if (vUv.x > 0.48 && vUv.x < 0.62 && vUv.y > 0.58 && vUv.y < 0.75) {
                                cityLights += smoothstep(0.65, 0.85, cityNoise) * 0.7;
                            }
                            
                            // East Asia
                            if (vUv.x > 0.7 && vUv.x < 0.9 && vUv.y > 0.5 && vUv.y < 0.7) {
                                cityLights += smoothstep(0.6, 0.9, cityNoise) * 0.9;
                            }
                            
                            vec3 lightColor = vec3(1.0, 0.8, 0.4);
                            earthColor += lightColor * cityLights * (1.0 - dayFactor) * 0.5;
                        }
                        
                        // Apply day/night lighting
                        earthColor *= 0.3 + 0.7 * max(0.1, dayFactor);
                        
                        // Atmospheric scattering
                        float fresnel = 1.0 - abs(dot(vNormal, vec3(0.0, 0.0, 1.0)));
                        vec3 atmosphereColor = vec3(0.4, 0.7, 1.0) * fresnel * 0.2;
                        earthColor += atmosphereColor;
                        
                        // Night mode override
                        if (nightMode > 0.5) {
                            earthColor *= 0.4;
                            earthColor += vec3(0.2, 0.4, 0.8) * 0.3;
                        }
                        
                        gl_FragColor = vec4(earthColor, 1.0);
                    }
                `
            });
            
            earth = new THREE.Mesh(geometry, material);
            earth.receiveShadow = true;
            scene.add(earth);
        }
        
        function createRealisticClouds() {
            const geometry = new THREE.SphereGeometry(CLOUD_RADIUS, 64, 32);
            
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 }
                },
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    varying vec2 vUv;
                    
                    float fbm(vec2 p) {
                        float value = 0.0;
                        float amplitude = 0.5;
                        float frequency = 1.0;
                        
                        for (int i = 0; i < 6; i++) {
                            value += amplitude * sin(dot(p * frequency, vec2(12.9898, 78.233)) + time * 0.1);
                            amplitude *= 0.5;
                            frequency *= 2.0;
                            p = p * 1.3;
                        }
                        return value * 0.5 + 0.5;
                    }
                    
                    void main() {
                        vec2 cloudUV = vUv * 4.0 + time * 0.02;
                        
                        float clouds = fbm(cloudUV);
                        clouds *= fbm(cloudUV * 2.1 + time * 0.015);
                        clouds *= fbm(cloudUV * 4.3 + time * 0.025);
                        
                        // Weather patterns
                        float weatherSystems = sin(vUv.x * 8.0 + time * 0.1) * cos(vUv.y * 6.0 + time * 0.08);
                        clouds += weatherSystems * 0.3;
                        
                        clouds = smoothstep(0.3, 0.8, clouds);
                        
                        // Hurricane/cyclone patterns
                        vec2 center1 = vec2(0.3, 0.4);
                        vec2 center2 = vec2(0.7, 0.6);
                        
                        float dist1 = distance(vUv, center1);
                        float dist2 = distance(vUv, center2);
                        
                        if (dist1 < 0.15) {
                            float angle = atan(vUv.y - center1.y, vUv.x - center1.x) + time * 0.3;
                            float spiral = sin(dist1 * 20.0 - time * 2.0) * 0.5 + 0.5;
                            clouds += spiral * (1.0 - dist1 / 0.15) * 0.6;
                        }
                        
                        gl_FragColor = vec4(1.0, 1.0, 1.0, clouds * 0.5);
                    }
                `,
                transparent: true,
                depthWrite: false
            });
            
            clouds = new THREE.Mesh(geometry, material);
            scene.add(clouds);
        }
        
        function createAtmosphere() {
            const geometry = new THREE.SphereGeometry(ATMOSPHERE_RADIUS, 64, 32);
            
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    c: { value: 0.8 },
                    p: { value: 4.0 }
                },
                vertexShader: `
                    varying vec3 vNormal;
                    void main() {
                        vNormal = normalize(normalMatrix * normal);
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float c;
                    uniform float p;
                    varying vec3 vNormal;
                    
                    void main() {
                        float intensity = pow(c - dot(vNormal, vec3(0.0, 0.0, 1.0)), p);
                        vec3 atmosphereColor = vec3(0.4, 0.7, 1.0);
                        gl_FragColor = vec4(atmosphereColor, 1.0) * intensity;
                    }
                `,
                side: THREE.BackSide,
                blending: THREE.AdditiveBlending,
                transparent: true
            });
            
            atmosphere = new THREE.Mesh(geometry, material);
            scene.add(atmosphere);
        }
        
        function createStars() {
            const starGeometry = new THREE.BufferGeometry();
            const starMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 2,
                transparent: true,
                opacity: 0.8
            });
            
            const starVertices = [];
            for (let i = 0; i < 2000; i++) {
                const x = (Math.random() - 0.5) * 200;
                const y = (Math.random() - 0.5) * 200;
                const z = (Math.random() - 0.5) * 200;
                starVertices.push(x, y, z);
            }
            
            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
            const stars = new THREE.Points(starGeometry, starMaterial);
            scene.add(stars);
        }
        
        function latLngToVector3(lat, lng, radius = EARTH_RADIUS * 1.01) {
            const phi = (90 - lat) * (Math.PI / 180);
            const theta = (lng + 180) * (Math.PI / 180);
            
            return new THREE.Vector3(
                -(radius * Math.sin(phi) * Math.cos(theta)),
                radius * Math.cos(phi),
                radius * Math.sin(phi) * Math.sin(theta)
            );
        }
        
        function createCargoHubs() {
            airportGroup = new THREE.Group();
            
            CARGO_HUBS.forEach(hub => {
                const position = latLngToVector3(hub.lat, hub.lng);
                
                let size = 0.05;
                let color = '#00ff88';
                let intensity = 0.5;
                
                if (hub.type === 'superhub') {
                    size = 0.12;
                    color = '#ff3366';
                    intensity = 1.0;
                } else if (hub.type === 'major') {
                    size = 0.08;
                    color = '#ffaa00';
                    intensity = 0.8;
                }
                
                // Main marker
                const geometry = new THREE.SphereGeometry(size, 16, 8);
                const material = new THREE.MeshBasicMaterial({
                    color: new THREE.Color(color),
                    transparent: true,
                    opacity: 0.9
                });
                
                const marker = new THREE.Mesh(geometry, material);
                marker.position.copy(position);
                
                // Pulsing glow effect
                const glowGeometry = new THREE.SphereGeometry(size * 2, 16, 8);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: new THREE.Color(color),
                    transparent: true,
                    opacity: 0.3,
                    blending: THREE.AdditiveBlending
                });
                
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                glow.position.copy(position);
                
                marker.userData = { hub, glow, intensity };
                
                airportGroup.add(marker);
                airportGroup.add(glow);
                
                // Add to radar
                addRadarDot(hub);
            });
            
            if (hubMarkers) scene.add(airportGroup);
        }
        
        function createCargoRoutes() {
            routeGroup = new THREE.Group();
            aircraftList = [];
            
            CARGO_ROUTES.forEach((route, routeIndex) => {
                const fromHub = CARGO_HUBS.find(h => h.code === route.from);
                const toHub = CARGO_HUBS.find(h => h.code === route.to);
                
                if (!fromHub || !toHub) return;
                
                const fromPos = latLngToVector3(fromHub.lat, fromHub.lng);
                const toPos = latLngToVector3(toHub.lat, toHub.lng);
                
                // Great circle route calculation
                const distance = fromPos.distanceTo(toPos);
                const midPoint = fromPos.clone().add(toPos).normalize();
                const height = distance * 0.3 + EARTH_RADIUS + 1;
                const arcTop = midPoint.multiplyScalar(height);
                
                const curve = new THREE.QuadraticBezierCurve3(fromPos, arcTop, toPos);
                
                // High-quality route line
                const points = curve.getPoints(200);
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                
                const material = new THREE.LineBasicMaterial({
                    color: new THREE.Color(route.color),
                    transparent: true,
                    opacity: 0.8,
                    linewidth: 3
                });
                
                const line = new THREE.Line(geometry, material);
                line.userData = { route };
                routeGroup.add(line);
                
                // Add realistic aircraft
                for (let i = 0; i < route.flights; i++) {
                    const aircraftGeometry = new THREE.ConeGeometry(0.03, 0.15, 6);
                    const aircraftMaterial = new THREE.MeshLambertMaterial({
                        color: new THREE.Color(route.color),
                        emissive: new THREE.Color(route.color),
                        emissiveIntensity: 0.3
                    });
                    
                    const aircraft = new THREE.Mesh(aircraftGeometry, aircraftMaterial);
                    
                    // Contrail effect
                    const contrailGeometry = new THREE.CylinderGeometry(0.005, 0.005, 0.5, 8);
                    const contrailMaterial = new THREE.MeshBasicMaterial({
                        color: 0xffffff,
                        transparent: true,
                        opacity: 0.3
                    });
                    const contrail = new THREE.Mesh(contrailGeometry, contrailMaterial);
                    contrail.position.z = -0.25;
                    aircraft.add(contrail);
                    
                    aircraftList.push({
                        mesh: aircraft,
                        curve: curve,
                        progress: i / route.flights,
                        speed: (0.001 + Math.random() * 0.002) * (route.volume / 100),
                        route: route,
                        callsign: LIVE_FLIGHTS[Math.floor(Math.random() * LIVE_FLIGHTS.length)] + String(routeIndex * 10 + i).padStart(2, '0'),
                        altitude: 35000 + Math.random() * 6000,
                        groundSpeed: 480 + Math.random() * 120
                    });
                    
                    routeGroup.add(aircraft);
                }
            });
            
            if (flightPaths) scene.add(routeGroup);
        }
        
        function addRadarDot(hub) {
            const radar = document.querySelector('.radar');
            const dot = document.createElement('div');
            dot.className = 'radar-dot';
            
            // Convert to radar coordinates (simplified projection)
            const x = ((hub.lng + 180) / 360) * 180;
            const y = ((hub.lat + 90) / 180) * 180;
            
            dot.style.left = Math.min(190, Math.max(5, x)) + 'px';
            dot.style.top = Math.min(190, Math.max(5, y)) + 'px';
            
            radar.appendChild(dot);
        }
        
        function setupAdvancedControls() {
            const container = document.getElementById('globe-container');
            
            // Mouse interaction
            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };
            
            container.addEventListener('mousedown', (event) => {
                isDragging = true;
                previousMousePosition = { x: event.clientX, y: event.clientY };
            });
            
            container.addEventListener('mousemove', (event) => {
                if (!isDragging) return;
                
                const deltaMove = {
                    x: event.clientX - previousMousePosition.x,
                    y: event.clientY - previousMousePosition.y
                };
                
                if (earth && !earthRotation) {
                    earth.rotation.y += deltaMove.x * 0.005;
                    earth.rotation.x += deltaMove.y * 0.005;
                    earth.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, earth.rotation.x));
                    
                    if (clouds) {
                        clouds.rotation.y = earth.rotation.y;
                        clouds.rotation.x = earth.rotation.x;
                    }
                }
                
                previousMousePosition = { x: event.clientX, y: event.clientY };
            });
            
            container.addEventListener('mouseup', () => {
                isDragging = false;
            });
            
            container.addEventListener('wheel', (event) => {
                event.preventDefault();
                const zoomSpeed = 0.5;
                camera.position.z += event.deltaY * zoomSpeed * 0.01;
                camera.position.z = Math.max(8, Math.min(50, camera.position.z));
                
                // Update coordinate display
                updateCoordinates();
            });
            
            // Button controls
            setupButtonControls();
        }
        
        function setupButtonControls() {
            document.getElementById('earth-rotation').addEventListener('click', function() {
                earthRotation = !earthRotation;
                this.classList.toggle('active', earthRotation);
                this.textContent = earthRotation ? 'üåç EARTH ROT' : 'üåç MANUAL';
            });
            
            document.getElementById('flight-paths').addEventListener('click', function() {
                flightPaths = !flightPaths;
                this.classList.toggle('active', flightPaths);
                this.textContent = flightPaths ? '‚úàÔ∏è FLIGHT PATHS' : '‚úàÔ∏è PATHS OFF';
                
                if (flightPaths) {
                    scene.add(routeGroup);
                } else {
                    scene.remove(routeGroup);
                }
            });
            
            document.getElementById('hub-markers').addEventListener('click', function() {
                hubMarkers = !hubMarkers;
                this.classList.toggle('active', hubMarkers);
                this.textContent = hubMarkers ? 'üè¢ HUB MARKERS' : 'üè¢ HUBS OFF';
                
                if (hubMarkers) {
                    scene.add(airportGroup);
                } else {
                    scene.remove(airportGroup);
                }
            });
            
            document.getElementById('night-mode').addEventListener('click', function() {
                nightMode = !nightMode;
                this.classList.toggle('active', nightMode);
                this.textContent = nightMode ? 'üåô DAY MODE' : 'üåô NIGHT MODE';
                
                if (earth && earth.material.uniforms) {
                    earth.material.uniforms.nightMode.value = nightMode ? 1.0 : 0.0;
                }
            });
            
            document.getElementById('weather-layer').addEventListener('click', function() {
                weatherLayer = !weatherLayer;
                this.classList.toggle('active', weatherLayer);
                this.textContent = weatherLayer ? '‚òÅÔ∏è CLEAR SKY' : '‚òÅÔ∏è WEATHER';
                
                if (clouds) {
                    clouds.visible = weatherLayer;
                }
            });
            
            document.getElementById('reset-view').addEventListener('click', () => {
                camera.position.set(0, 0, 20);
                if (earth) {
                    earth.rotation.set(0, 0, 0);
                    if (clouds) {
                        clouds.rotation.set(0, 0, 0);
                    }
                }
                updateCoordinates();
            });
        }
        
        function initializeUI() {
            // Create starfield
            createStarfield();
            
            // Initialize time display
            updateTime();
            setInterval(updateTime, 1000);
            
            // Initialize flight telemetry
            updateFlightTelemetry();
            setInterval(updateFlightTelemetry, 3000);
            
            // Show HUD after loading
            setTimeout(() => {
                document.getElementById('nasa-hud').style.display = 'block';
            }, 2000);
        }
        
        function createStarfield() {
            const starfield = document.getElementById('starfield');
            for (let i = 0; i < 100; i++) {
                const star = document.createElement('div');
                star.className = 'star';
                star.style.left = Math.random() * 100 + '%';
                star.style.top = Math.random() * 100 + '%';
                star.style.width = (Math.random() * 3 + 1) + 'px';
                star.style.height = star.style.width;
                star.style.animationDelay = Math.random() * 3 + 's';
                starfield.appendChild(star);
            }
        }
        
        function updateTime() {
            const now = new Date();
            const utcTime = now.toUTCString().split(' ')[4];
            document.getElementById('utc-time').textContent = utcTime;
        }
        
        function updateFlightTelemetry() {
            const telemetryDiv = document.getElementById('flight-telemetry');
            let html = '';
            
            // Show random active flights
            for (let i = 0; i < 6; i++) {
                const aircraft = aircraftList[Math.floor(Math.random() * aircraftList.length)];
                if (aircraft) {
                    const status = Math.random() > 0.1 ? 'EN ROUTE' : 'DELAYED';
                    const statusColor = status === 'EN ROUTE' ? '#00ff88' : '#ff6600';
                    
                    html += `
                        <div class="flight-info">
                            <span class="flight-code">${aircraft.callsign}</span>
                            <span class="flight-status" style="color: ${statusColor}">${status}</span>
                        </div>
                    `;
                }
            }
            
            telemetryDiv.innerHTML = html;
        }
        
        function updateCoordinates() {
            const coords = document.getElementById('coordinates');
            const altitude = camera.position.z * 1000;
            const velocity = earthRotation ? 0.002 : 0.000;
            
            coords.innerHTML = `
                LAT: ${(Math.random() * 180 - 90).toFixed(4)}¬∞<br>
                LNG: ${(Math.random() * 360 - 180).toFixed(4)}¬∞<br>
                ALT: ${altitude.toFixed(0)}km<br>
                VEL: ${velocity.toFixed(3)}¬∞/s
            `;
        }
        
        function updateFPS() {
            frameCount++;
            const now = Date.now();
            if (now - lastTime >= 1000) {
                fps = frameCount;
                frameCount = 0;
                lastTime = now;
                document.getElementById('fps-counter').textContent = `FPS: ${fps}`;
            }
        }
        
        function startMission() {
            // Hide loading screen
            setTimeout(() => {
                document.getElementById('loading').style.display = 'none';
            }, 3000);
            
            // Start animation loop
            animate();
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            const time = Date.now() * 0.001;
            
            // Earth rotation
            if (earthRotation && earth) {
                earth.rotation.y += 0.002;
                if (clouds) {
                    clouds.rotation.y += 0.0015;
                }
            }
            
            // Update shaders
            if (earth && earth.material.uniforms) {
                earth.material.uniforms.time.value = time;
            }
            
            if (clouds && clouds.material.uniforms) {
                clouds.material.uniforms.time.value = time;
            }
            
            // Animate aircraft
            aircraftList.forEach(aircraft => {
                aircraft.progress += aircraft.speed;
                if (aircraft.progress > 1) {
                    aircraft.progress = 0;
                }
                
                const position = aircraft.curve.getPoint(aircraft.progress);
                const nextPosition = aircraft.curve.getPoint(Math.min(aircraft.progress + 0.01, 1));
                
                aircraft.mesh.position.copy(position);
                aircraft.mesh.lookAt(nextPosition);
                
                // Animate contrails
                if (aircraft.mesh.children.length > 0) {
                    aircraft.mesh.children[0].material.opacity = 0.2 + Math.sin(time * 2) * 0.1;
                }
            });
            
            // Animate hub glow effects
            if (airportGroup) {
                airportGroup.children.forEach(child => {
                    if (child.userData && child.userData.glow) {
                        const intensity = child.userData.intensity;
                        const pulse = Math.sin(time * 3) * 0.2 + 0.8;
                        child.userData.glow.material.opacity = intensity * pulse * 0.3;
                        child.userData.glow.scale.setScalar(1 + pulse * 0.2);
                    }
                });
            }
            
            updateFPS();
            updateCoordinates();
            
            renderer.render(scene, camera);
        }
        
        // Handle window resize
        window.addEventListener('resize', () => {
            const container = document.getElementById('globe-container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        });
        
        // Initialize when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>