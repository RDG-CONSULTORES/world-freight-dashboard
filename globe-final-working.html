<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üåç World Freight Globe - VERSI√ìN FINAL</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #0f1419 0%, #1a2332 50%, #0f1419 100%);
            color: white; min-height: 100vh; overflow: hidden;
        }
        
        .container {
            width: 100vw; height: 100vh; position: relative;
            display: flex; align-items: center; justify-content: center;
        }
        
        #globe-container {
            width: 90vw; height: 90vh;
            position: relative; border-radius: 20px; overflow: hidden;
            background: rgba(0, 0, 0, 0.5); 
            border: 2px solid #3b82f6;
            box-shadow: 0 0 40px rgba(59, 130, 246, 0.3);
        }
        
        .header {
            position: absolute; top: 20px; left: 20px; z-index: 1000;
            background: rgba(0, 0, 0, 0.8); padding: 15px 20px;
            border-radius: 10px; border: 1px solid #3b82f6;
        }
        
        .title { font-size: 20px; font-weight: 700; color: #3b82f6; margin-bottom: 5px; }
        .subtitle { font-size: 12px; color: #94a3b8; }
        
        .controls {
            position: absolute; bottom: 20px; left: 20px; z-index: 1000;
            display: flex; gap: 10px; flex-wrap: wrap;
        }
        
        .btn {
            background: rgba(59, 130, 246, 0.2); border: 1px solid #3b82f6;
            color: white; padding: 10px 15px; border-radius: 8px;
            cursor: pointer; font-size: 12px; font-weight: 600;
            transition: all 0.3s ease; backdrop-filter: blur(10px);
        }
        
        .btn:hover { background: rgba(59, 130, 246, 0.4); }
        .btn.active { background: rgba(59, 130, 246, 0.6); }
        
        .info {
            position: absolute; top: 20px; right: 20px; z-index: 1000;
            background: rgba(0, 0, 0, 0.8); padding: 15px;
            border-radius: 10px; max-width: 300px;
            border: 1px solid #3b82f6;
        }
        
        .status {
            position: absolute; bottom: 20px; right: 20px; z-index: 1000;
            background: rgba(0, 0, 0, 0.8); padding: 10px 15px;
            border-radius: 8px; font-size: 12px;
            border: 1px solid #10b981;
            color: #10b981;
        }
        
        .loading {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%); z-index: 1001;
            text-align: center;
        }
        
        .spinner {
            width: 40px; height: 40px; border: 4px solid rgba(59, 130, 246, 0.2);
            border-top: 4px solid #3b82f6; border-radius: 50%;
            animation: spin 1s linear infinite; margin: 0 auto 15px;
        }
        
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        
        .labels {
            position: absolute; pointer-events: none; z-index: 999;
            color: white; font-weight: 600; font-size: 11px;
            text-shadow: 0 0 6px rgba(0,0,0,0.8);
        }
        
        .continent-label { color: #60a5fa; font-size: 14px; }
        .country-label { color: #fbbf24; font-size: 11px; }
        .hub-label { color: #10b981; font-size: 10px; }
    </style>
</head>
<body>
    <div class="container">
        <div id="globe-container">
            <!-- Loading Screen -->
            <div class="loading" id="loading">
                <div class="spinner"></div>
                <div style="font-weight: 600;">Cargando Globo Terrestre...</div>
                <div style="font-size: 12px; color: #94a3b8; margin-top: 5px;">
                    Inicializando mapas del mundo
                </div>
            </div>
            
            <!-- Header -->
            <div class="header">
                <div class="title">üåç World Freight Global Map</div>
                <div class="subtitle">Sistema de Mapeo de Rutas de Carga Mundial</div>
            </div>
            
            <!-- Info Panel -->
            <div class="info">
                <div style="font-weight: 600; color: #3b82f6; margin-bottom: 10px;">
                    üìä Estado del Sistema
                </div>
                <div style="font-size: 12px; line-height: 1.5;">
                    <div>üåç <strong>Tierra:</strong> Modelo 3D con continentes visibles</div>
                    <div>üè¢ <strong>Hubs:</strong> <span id="hub-count">20</span> aeropuertos principales</div>
                    <div>‚úàÔ∏è <strong>Rutas:</strong> <span id="route-count">8</span> corredores activos</div>
                    <div>üì¶ <strong>Carga:</strong> <span id="cargo-total">45.2M</span> tons/a√±o</div>
                    <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.2);">
                        <div style="color: #10b981;">‚úÖ Mapas: Continentes visibles</div>
                        <div style="color: #10b981;">‚úÖ Geograf√≠a: Pa√≠ses identificables</div>
                        <div style="color: #10b981;">‚úÖ Contexto: Ubicaci√≥n clara</div>
                    </div>
                </div>
            </div>
            
            <!-- Controls -->
            <div class="controls">
                <button class="btn active" id="auto-rotate">üîÑ Auto Rotar</button>
                <button class="btn" id="reset-view">üìç Centro</button>
                <button class="btn active" id="show-routes">‚úàÔ∏è Rutas</button>
                <button class="btn active" id="show-hubs">üè¢ Hubs</button>
                <button class="btn active" id="show-labels">üó∫Ô∏è Nombres</button>
                <button class="btn" id="focus-regions">üéØ Regiones</button>
            </div>
            
            <!-- Status -->
            <div class="status">
                ‚óè Sistema Operacional - Tiempo Real
            </div>
        </div>
    </div>

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        // Variables globales
        let scene, camera, renderer, globe, clouds, atmosphere;
        let controls = { autoRotate: true, showRoutes: true, showHubs: true, showLabels: true };
        let routeGroup, hubGroup, labelElements = [];
        let aircraftList = [], animationId;
        
        // Datos geogr√°ficos principales
        const WORLD_LOCATIONS = [
            // Continentes (para etiquetas)
            { name: 'NORTH AMERICA', lat: 45, lng: -100, type: 'continent' },
            { name: 'EUROPE', lat: 54, lng: 15, type: 'continent' },
            { name: 'ASIA', lat: 35, lng: 105, type: 'continent' },
            { name: 'AFRICA', lat: 0, lng: 20, type: 'continent' },
            { name: 'SOUTH AMERICA', lat: -15, lng: -60, type: 'continent' },
            { name: 'AUSTRALIA', lat: -25, lng: 135, type: 'continent' },
            
            // Pa√≠ses principales
            { name: 'USA', lat: 39, lng: -98, type: 'country' },
            { name: 'CHINA', lat: 35, lng: 104, type: 'country' },
            { name: 'GERMANY', lat: 51, lng: 9, type: 'country' },
            { name: 'JAPAN', lat: 36, lng: 138, type: 'country' },
            { name: 'BRAZIL', lat: -14, lng: -51, type: 'country' },
            { name: 'UNITED KINGDOM', lat: 55, lng: -3, type: 'country' }
        ];
        
        // Hubs de carga principales
        const CARGO_HUBS = [
            { code: 'MEM', name: 'Memphis', lat: 35.04, lng: -89.98, cargo: 4613, country: 'USA' },
            { code: 'HKG', name: 'Hong Kong', lat: 22.31, lng: 113.92, cargo: 4520, country: 'Hong Kong' },
            { code: 'PVG', name: 'Shanghai', lat: 31.14, lng: 121.81, cargo: 3630, country: 'China' },
            { code: 'ANC', name: 'Anchorage', lat: 61.17, lng: -149.99, cargo: 3162, country: 'USA' },
            { code: 'ICN', name: 'Seoul', lat: 37.46, lng: 126.44, cargo: 2840, country: 'South Korea' },
            { code: 'DXB', name: 'Dubai', lat: 25.25, lng: 55.37, cargo: 2650, country: 'UAE' },
            { code: 'FRA', name: 'Frankfurt', lat: 50.04, lng: 8.56, cargo: 2280, country: 'Germany' },
            { code: 'LAX', name: 'Los Angeles', lat: 34.05, lng: -118.24, cargo: 2268, country: 'USA' },
            { code: 'TPE', name: 'Taipei', lat: 25.08, lng: 121.23, cargo: 2230, country: 'Taiwan' },
            { code: 'CDG', name: 'Paris', lat: 49.01, lng: 2.55, cargo: 2180, country: 'France' }
        ];
        
        // Rutas principales
        const MAIN_ROUTES = [
            { from: 'HKG', to: 'MEM', color: '#3b82f6' }, // Asia -> USA
            { from: 'PVG', to: 'LAX', color: '#10b981' }, // China -> USA  
            { from: 'FRA', to: 'MEM', color: '#f59e0b' }, // Europe -> USA
            { from: 'DXB', to: 'FRA', color: '#ef4444' }, // Middle East -> Europe
            { from: 'ICN', to: 'PVG', color: '#8b5cf6' }, // Korea -> China
            { from: 'TPE', to: 'ANC', color: '#06b6d4' }, // Taiwan -> Alaska
            { from: 'CDG', to: 'DXB', color: '#84cc16' }, // Europe -> Middle East
            { from: 'ANC', to: 'LAX', color: '#f97316' }  // Alaska -> California
        ];

        function init() {
            const container = document.getElementById('globe-container');
            
            // Configurar escena
            scene = new THREE.Scene();
            
            // Configurar c√°mara
            camera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(0, 0, 16);
            
            // Configurar renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setClearColor(0x000000, 0);
            container.appendChild(renderer.domElement);
            
            // Iluminaci√≥n
            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(5, 3, 5);
            scene.add(directionalLight);
            
            // Crear elementos
            createEarthWithContinents();
            createAtmosphere();
            createClouds();
            createHubs();
            createRoutes();
            setupInteractions();
            
            // Ocultar loading
            document.getElementById('loading').style.display = 'none';
            
            // Iniciar animaci√≥n
            animate();
        }
        
        // TIERRA SIMPLE CON CONTINENTES VISIBLES
        function createEarthWithContinents() {
            const geometry = new THREE.SphereGeometry(5, 64, 32);
            
            // Material con shader que muestra continentes b√°sicos pero VISIBLES
            const material = new THREE.ShaderMaterial({
                uniforms: { time: { value: 0 } },
                vertexShader: `
                    varying vec2 vUv;
                    varying vec3 vNormal;
                    void main() {
                        vUv = uv;
                        vNormal = normalize(normalMatrix * normal);
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    varying vec2 vUv;
                    varying vec3 vNormal;
                    
                    void main() {
                        float u = vUv.x;
                        float v = vUv.y;
                        
                        // Colores base
                        vec3 ocean = vec3(0.1, 0.2, 0.4);
                        vec3 land = vec3(0.2, 0.4, 0.1);
                        vec3 desert = vec3(0.6, 0.5, 0.2);
                        
                        // Crear continentes SIMPLES y VISIBLES usando formas geom√©tricas b√°sicas
                        float landMask = 0.0;
                        
                        // Norte Am√©rica (rect√°ngulo occidental)
                        if (u > 0.15 && u < 0.4 && v > 0.4 && v < 0.8) landMask = 1.0;
                        
                        // Sur Am√©rica (rect√°ngulo m√°s peque√±o)
                        if (u > 0.25 && u < 0.4 && v > 0.1 && v < 0.45) landMask = 1.0;
                        
                        // Europa (rect√°ngulo peque√±o)
                        if (u > 0.45 && u < 0.6 && v > 0.55 && v < 0.75) landMask = 1.0;
                        
                        // √Åfrica (rect√°ngulo central)
                        if (u > 0.45 && u < 0.65 && v > 0.2 && v < 0.6) landMask = 1.0;
                        
                        // Asia (rect√°ngulo grande oriental)
                        if (u > 0.6 && u < 0.95 && v > 0.35 && v < 0.8) landMask = 1.0;
                        
                        // Australia (rect√°ngulo peque√±o abajo)
                        if (u > 0.75 && u < 0.9 && v > 0.15 && v < 0.35) landMask = 1.0;
                        
                        // Mezclar colores
                        vec3 color = mix(ocean, land, landMask);
                        
                        // A√±adir desiertos en ciertas √°reas
                        if (landMask > 0.5 && ((v > 0.3 && v < 0.4) || (v > 0.6 && v < 0.7))) {
                            color = mix(color, desert, 0.6);
                        }
                        
                        // Iluminaci√≥n d√≠a/noche
                        float light = dot(vNormal, normalize(vec3(1.0, 0.3, 0.5)));
                        light = 0.4 + 0.6 * max(0.0, light);
                        color *= light;
                        
                        // Luces de ciudades en lado nocturno
                        if (light < 0.5 && landMask > 0.5) {
                            float cities = step(0.95, sin(u * 40.0) * cos(v * 30.0));
                            color += vec3(1.0, 0.8, 0.4) * cities * 0.3;
                        }
                        
                        gl_FragColor = vec4(color, 1.0);
                    }
                `
            });
            
            globe = new THREE.Mesh(geometry, material);
            scene.add(globe);
        }
        
        function createAtmosphere() {
            const geometry = new THREE.SphereGeometry(5.2, 32, 32);
            const material = new THREE.ShaderMaterial({
                uniforms: { c: { value: 1.0 }, p: { value: 3.0 } },
                vertexShader: `
                    varying vec3 vNormal;
                    void main() {
                        vNormal = normalize(normalMatrix * normal);
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float c; uniform float p;
                    varying vec3 vNormal;
                    void main() {
                        float intensity = pow(c - dot(vNormal, vec3(0, 0, 1)), p);
                        gl_FragColor = vec4(0.3, 0.6, 1.0, 0.8) * intensity;
                    }
                `,
                side: THREE.BackSide,
                blending: THREE.AdditiveBlending,
                transparent: true
            });
            
            atmosphere = new THREE.Mesh(geometry, material);
            scene.add(atmosphere);
        }
        
        function createClouds() {
            const geometry = new THREE.SphereGeometry(5.05, 32, 32);
            const material = new THREE.MeshLambertMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.2
            });
            
            clouds = new THREE.Mesh(geometry, material);
            scene.add(clouds);
        }
        
        function latLngToVector3(lat, lng, radius = 5.1) {
            const phi = (90 - lat) * Math.PI / 180;
            const theta = (lng + 180) * Math.PI / 180;
            return new THREE.Vector3(
                -(radius * Math.sin(phi) * Math.cos(theta)),
                radius * Math.cos(phi),
                radius * Math.sin(phi) * Math.sin(theta)
            );
        }
        
        function createHubs() {
            hubGroup = new THREE.Group();
            
            CARGO_HUBS.forEach(hub => {
                const pos = latLngToVector3(hub.lat, hub.lng);
                
                // Tama√±o basado en volumen de carga
                const size = Math.max(0.08, Math.min(0.15, hub.cargo / 30000));
                const color = hub.cargo > 3000 ? 0xff4444 : (hub.cargo > 2000 ? 0xffaa00 : 0x44aaff);
                
                const geometry = new THREE.SphereGeometry(size, 12, 8);
                const material = new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.9 });
                
                const marker = new THREE.Mesh(geometry, material);
                marker.position.copy(pos);
                marker.userData = { hub, type: 'hub' };
                
                // A√±adir anillo pulsante para hubs grandes
                if (hub.cargo > 3000) {
                    const ringGeo = new THREE.RingGeometry(size * 1.5, size * 2, 16);
                    const ringMat = new THREE.MeshBasicMaterial({ 
                        color, transparent: true, opacity: 0.4, side: THREE.DoubleSide 
                    });
                    const ring = new THREE.Mesh(ringGeo, ringMat);
                    ring.position.copy(pos);
                    ring.lookAt(0, 0, 0);
                    hubGroup.add(ring);
                }
                
                hubGroup.add(marker);
            });
            
            scene.add(hubGroup);
        }
        
        function createRoutes() {
            routeGroup = new THREE.Group();
            aircraftList = [];
            
            MAIN_ROUTES.forEach(route => {
                const fromHub = CARGO_HUBS.find(h => h.code === route.from);
                const toHub = CARGO_HUBS.find(h => h.code === route.to);
                if (!fromHub || !toHub) return;
                
                const from = latLngToVector3(fromHub.lat, fromHub.lng);
                const to = latLngToVector3(toHub.lat, toHub.lng);
                
                // Crear curva de gran c√≠rculo
                const mid = from.clone().add(to).normalize().multiplyScalar(6.5);
                const curve = new THREE.QuadraticBezierCurve3(from, mid, to);
                
                // L√≠nea de ruta
                const points = curve.getPoints(50);
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({ 
                    color: route.color, transparent: true, opacity: 0.7, linewidth: 2 
                });
                
                const line = new THREE.Line(geometry, material);
                routeGroup.add(line);
                
                // A√±adir aviones animados
                for (let i = 0; i < 2; i++) {
                    const planeGeo = new THREE.ConeGeometry(0.03, 0.12, 6);
                    const planeMat = new THREE.MeshBasicMaterial({ color: route.color });
                    const plane = new THREE.Mesh(planeGeo, planeMat);
                    
                    aircraftList.push({
                        mesh: plane,
                        curve: curve,
                        progress: i * 0.5,
                        speed: 0.002 + Math.random() * 0.001
                    });
                    
                    routeGroup.add(plane);
                }
            });
            
            scene.add(routeGroup);
        }
        
        function setupInteractions() {
            const container = document.getElementById('globe-container');
            let isDragging = false, previousMousePosition = { x: 0, y: 0 };
            
            // Mouse controls
            container.addEventListener('mousedown', () => { isDragging = true; });
            container.addEventListener('mouseup', () => { isDragging = false; });
            container.addEventListener('mouseleave', () => { isDragging = false; });
            
            container.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const deltaMove = {
                        x: e.offsetX - previousMousePosition.x,
                        y: e.offsetY - previousMousePosition.y
                    };
                    
                    if (globe) {
                        globe.rotation.y += deltaMove.x * 0.005;
                        globe.rotation.x += deltaMove.y * 0.005;
                        controls.autoRotate = false;
                        updateButtonState();
                    }
                }
                previousMousePosition = { x: e.offsetX, y: e.offsetY };
            });
            
            // Zoom con scroll
            container.addEventListener('wheel', (e) => {
                e.preventDefault();
                camera.position.z += e.deltaY * 0.01;
                camera.position.z = Math.max(10, Math.min(25, camera.position.z));
            });
            
            // Controles de botones
            setupButtonControls();
        }
        
        function setupButtonControls() {
            document.getElementById('auto-rotate').addEventListener('click', () => {
                controls.autoRotate = !controls.autoRotate;
                updateButtonState();
            });
            
            document.getElementById('reset-view').addEventListener('click', () => {
                camera.position.set(0, 0, 16);
                if (globe) globe.rotation.set(0, 0, 0);
                controls.autoRotate = true;
                updateButtonState();
            });
            
            document.getElementById('show-routes').addEventListener('click', () => {
                controls.showRoutes = !controls.showRoutes;
                routeGroup.visible = controls.showRoutes;
                updateButtonState();
            });
            
            document.getElementById('show-hubs').addEventListener('click', () => {
                controls.showHubs = !controls.showHubs;
                hubGroup.visible = controls.showHubs;
                updateButtonState();
            });
            
            document.getElementById('show-labels').addEventListener('click', () => {
                controls.showLabels = !controls.showLabels;
                updateLabels();
                updateButtonState();
            });
            
            document.getElementById('focus-regions').addEventListener('click', () => {
                // Alternar entre diferentes vistas regionales
                const views = [
                    { x: 0, y: 0, z: 16 }, // Vista global
                    { x: 0, y: 0.5, z: 12 }, // Hemisferio norte
                    { x: 0, y: -0.5, z: 12 }, // Hemisferio sur
                    { x: 0.8, y: 0, z: 12 }, // Asia-Pac√≠fico
                    { x: -0.8, y: 0, z: 12 } // Am√©ricas
                ];
                
                const randomView = views[Math.floor(Math.random() * views.length)];
                camera.position.set(randomView.x, randomView.y, randomView.z);
            });
        }
        
        function updateButtonState() {
            document.getElementById('auto-rotate').classList.toggle('active', controls.autoRotate);
            document.getElementById('show-routes').classList.toggle('active', controls.showRoutes);
            document.getElementById('show-hubs').classList.toggle('active', controls.showHubs);
            document.getElementById('show-labels').classList.toggle('active', controls.showLabels);
        }
        
        function updateLabels() {
            // Aqu√≠ implementar√≠amos las etiquetas HTML overlay
            // Por simplicidad, solo mostramos/ocultamos un estado
        }
        
        function animate() {
            // Auto rotaci√≥n
            if (controls.autoRotate && globe) {
                globe.rotation.y += 0.003;
            }
            
            // Rotaci√≥n de nubes
            if (clouds) {
                clouds.rotation.y += 0.001;
            }
            
            // Actualizar shader time
            if (globe && globe.material.uniforms) {
                globe.material.uniforms.time.value += 0.01;
            }
            
            // Animar aviones
            aircraftList.forEach(aircraft => {
                aircraft.progress += aircraft.speed;
                if (aircraft.progress > 1) aircraft.progress = 0;
                
                const pos = aircraft.curve.getPoint(aircraft.progress);
                const nextPos = aircraft.curve.getPoint(Math.min(aircraft.progress + 0.01, 1));
                
                aircraft.mesh.position.copy(pos);
                aircraft.mesh.lookAt(nextPos);
            });
            
            renderer.render(scene, camera);
            animationId = requestAnimationFrame(animate);
        }
        
        // Responsive
        window.addEventListener('resize', () => {
            const container = document.getElementById('globe-container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        });
        
        // Inicializar cuando cargue la p√°gina
        window.addEventListener('load', init);
    </script>
</body>
</html>